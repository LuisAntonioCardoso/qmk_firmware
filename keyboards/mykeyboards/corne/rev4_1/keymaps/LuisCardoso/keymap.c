/* =============================================================================
 * Keymap for Corne v4.1 - LuisCardoso
 * =============================================================================
 *
 * Split keyboard layout: LAYOUT_split_3x6_3_ex2 (46 keys + 2 extra per side)
 * Per-key RGB LEDs (46 total) — per-layer HSV color + warm white indicators
 *
 * LAYERS (10 total):
 *   Base layers (EEPROM-persisted HSV):
 *     MAI - Custom Colemak (default)
 *     QRT - QWERTY
 *     GAM - Gaming (no left-hand hold modifiers)
 *   Temporary layers:
 *     NUM - Numpad (inverted: 1-2-3 top, 7-8-9 bottom)
 *     SMB - Symbols (right hand)
 *     ARW - Arrows and navigation (right hand)
 *     COD - Code/brackets (left hand)
 *     SHR - One-handed shortcuts (left hand, Ctrl+key combos)
 *   Special layers:
 *     SWX - SWITCHER menu (3-thumb hold to activate)
 *     CNF - CONFIG (dual-ESC hold to activate, per-layer HSV control)
 *
 * FEATURES:
 *   - 3-thumb SWITCHER: hold all 3 thumbs for 500ms to enter layer switcher
 *   - Dual-ESC CONFIG: hold both ESC keys for 500ms to enter HSV config
 *   - Shift+inner thumb tap → Caps Lock toggle (both hands)
 *   - Per-layer HSV control with LED toggle, saved to EEPROM
 *   - Warm white modifier column indicators (Ctrl/Shift/Alt)
 *   - Split sync: configs synced between master and slave every 1s
 *   - CFG_PRT key: types current HSV values for easy default updates
 *
 * CNF LAYER CONTROLS (both hands mirrored):
 *   Ring finger:   LED_TOG (row 0) / VAL_UP (row 1) / VAL_DN (row 2)
 *   Middle finger: SAT_UP (row 1) / SAT_DN (row 2)
 *   Index finger:  HUE_UP (row 1) / HUE_DN (row 2)
 *   Inner column:  CFG_RST (row 1) / CFG_PRT (row 2)
 *   Outer pinky:   CFG_EXIT (row 2) - saves to EEPROM and exits
 *
 * =============================================================================
 * EDITING INSTRUCTIONS — READ BEFORE MODIFYING THIS FILE
 * =============================================================================
 *
 * The layer definitions use a specific formatting with TABS and SPACES for
 * alignment. Many editors will auto-format on save and BREAK this formatting.
 *
 * TO SAFELY EDIT LAYERS:
 *
 * 1. DISABLE AUTO-FORMAT ON SAVE in your editor before editing this file
 *    - VSCode: set "editor.formatOnSave": false for this workspace
 *    - Vim: :set noautoindent nosmartindent
 *
 * 2. USE SED FOR SIMPLE KEY CHANGES (recommended):
 *    sed -i 's/OLD_KEY/NEW_KEY/' keymap.c
 *    Example: sed -i 's/KC_RBRC/KC_LBRC/' keymap.c
 *
 * 3. FOR LARGER CHANGES, use the head/cat/tail method:
 *    - Find line numbers: grep -n "LAYER_NAME" keymap.c
 *    - Extract: head -N keymap.c > tmp.c && tail -n +M keymap.c >> tmp.c
 *    - Edit tmp.c manually, then: mv tmp.c keymap.c
 *
 * 4. LAYER CODE LINE FORMAT (preserve exactly):
 *    - Row 0: TAB + 4 spaces + keys with padding
 *    - Row 1: TAB + TAB + keys with padding
 *    - Row 2: TAB + TAB + keys with padding (6 keys, no extra)
 *    - Thumbs: ~53 spaces + 3 keys each side
 *    - Separator between halves: comma then comment markers
 *    - Each key padded to ~12 characters with spaces before comma
 *
 * 5. COMMENT LINES (// ...) can be edited freely, they don't affect compilation
 *
 * 6. ALWAYS COMPILE after editing: qmk compile -kb mykeyboards/corne/rev4_1 -km LuisCardoso
 *
 * =============================================================================
 */

#include QMK_KEYBOARD_H
#include "transactions.h"
// =============================================================================
// ENUMS — Layers and custom keycodes
// =============================================================================

enum layers { MAI, QRT, GAM, NUM, SMB, ARW, COD, SHR, SWX, CNF };

enum custom_keycodes {
    CKC_QU = SAFE_RANGE, // Tap Q then U (or just Q when Ctrl+Shift held)
    CKC_BSD,             // Backspace, or Delete when Shift held
    NUMB_T,              // Toggle NUM layer lock

    SW_MAIN, // SWITCHER: switch to MAIN
    SW_QWRT, // SWITCHER: switch to QWERTY
    SW_GAME, // SWITCHER: switch to GAME

    LTL, // Left Thumb Left  (outer)  — GUI hold (modifier) / GUI tap
    LTM, // Left Thumb Mid   — Enter tap / NUM hold
    LTR, // Left Thumb Right (inner)  — SHR hold / Shift+tap → Caps Lock toggle

    RTL, // Right Thumb Left  (inner)  — Shift+tap → Caps Lock toggle
    RTM, // Right Thumb Mid   — Space tap / ARW hold
    RTR, // Right Thumb Right (outer)  — placeholder

    // CONFIG layer HSV controls (per current_base_layer)
    LED_TOG,  // Toggle LEDs on/off (preserves HSV values)
    HUE_UP,   // Increase hue
    HUE_DN,   // Decrease hue
    SAT_UP,   // Increase saturation
    SAT_DN,   // Decrease saturation
    VAL_UP,   // Increase value (brightness)
    VAL_DN,   // Decrease value (brightness)
    CFG_EXIT, // CONFIG: exit layer
    CFG_RST,  // CONFIG: reset layer configs to defaults
    CFG_PRT   // CONFIG: print current config values (types them out)
};

// =============================================================================
// LED INDEX MAPPING
// =============================================================================
/*
 * LED wiring order (from rgb_matrix.layout in info.json):
 *   Left side (LEDs 0-22):                Right side (LEDs 23-45):
 *   Thumbs: 0,7,8 (inner→outer)           Thumbs: 23,30,31 (inner→outer)
 *   Row 2:  1,6,9,14,15,20 (inner→outer)  Row 2:  24,29,32,37,38,43 (inner→outer)
 *   Row 1:  2,5,10,13,16,19,22 (i→o+ex)   Row 1:  25,28,33,36,39,42,45 (i→o+ex)
 *   Row 0:  3,4,11,12,17,18,21 (i→o+ex)   Row 0:  26,27,34,35,40,41,44 (i→o+ex)
 *
 * Key positions (MAIN layer) — showing inner→outer for visual keyboard order:
 *   Left Row 0:  BspDel(18) NO(17)  Q(12)  O(11)  U(4)   B(3)   NO(21)
 *   Left Row 1:  TAB(19)    C(16)   S(13)  E(10)  A(5)   I(2)   NO(22)
 *   Left Row 2:  ESC(20)    COMM(15) Z(14) X(9)   Y(6)   J(1)
 *   Left Thumbs: LTL(8)     LTM(7)   LTR(0)
 *   Right Row 0: VOLU(44)   K(26)   G(27)  L(34)  W(35)  NO(40) SCLN(41)
 *   Right Row 1: VOLD(45)   D(25)   T(28)  R(33)  N(36)  H(39)  BspDel(42)
 *   Right Row 2: F(24)      M(29)   V(32)  P(37)  DOT(38) ESC(43)
 *   Right Thumbs:RTL(23)    RTM(30)  RTR(31)
 *
 * Finger columns (modifier / layer indicators) — by matrix column:
 *   Index  (col 4): Left 4,5,6      Right 27,28,29
 *   Middle (col 3): Left 11,10,9   Right 34,33,32
 *   Ring   (col 2): Left 12,13,14  Right 35,36,37
 *   Pinky  (col 1): Left 17,16,15  Right 40,39,38
 *   Outer  (col 0): Left 18,19,20  Right 41,42,43
 *   Inner+ (col 5): Left 3,2,1     Right 26,25,24
 *   Extra  (col 6): Left 21,22     Right 44,45
 */

// Matrix position → LED index.  255 = no LED at that position.
static const uint8_t matrix_to_led[8][7] = {
    // Left side
    {18, 17, 12, 11, 4, 3, 21},    // Row 0
    {19, 16, 13, 10, 5, 2, 22},    // Row 1
    {20, 15, 14, 9, 6, 1, 255},    // Row 2  (no col 6)
    {255, 255, 255, 8, 7, 0, 255}, // Row 3  (thumbs only: cols 3-5)
    // Right side
    {41, 40, 35, 34, 27, 26, 44},    // Row 4
    {42, 39, 36, 33, 28, 25, 45},    // Row 5
    {43, 38, 37, 32, 29, 24, 255},   // Row 6  (no col 6)
    {255, 255, 255, 31, 30, 23, 255} // Row 7  (thumbs only: cols 3-5)
};

uint8_t get_led_index(uint8_t row, uint8_t col) {
    if (row >= 8 || col >= 7) return 255;
    return matrix_to_led[row][col];
}

// =============================================================================
// KEYMAPS
// =============================================================================

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    /* MAIN Layer
     *                                               .-------------------------------------------------------.    .-------------------------------------------------------.
     *                                               |BspDel |  NO   |   Q   |   O   |   U   |   B   |  NO   |    | VOLU  |   K   |   G   |   L   |   W   |   NO  | SCLN  |
     *                                               |-------+-------+-------+-------+-------+-------+-------|    |-------+-------+-------+-------+-------+-------+-------|
     *                                               |  TAB  | C/SMB | S/SFT | E/ALT | A/CTL |   I   |  NO   |    | VOLD  |   D   | T/CTL | R/ALT | N/SFT | H/COD |BspDel |
     *                                               |-------+-------+-------+-------+-------+-------+-------'    '-------|-------+-------+-------+-------+-------+-------|
     *                                               |  ESC  | COMM  |   Z   |   X   |   Y   |   J   |                    |   F   |   M   |   V   |   P   |  DOT  |  ESC  |
     *                                               '-----------------------+-------+-------+-------|                    |-------+-------+-------+-----------------------'
     *                                                                       |  GUI  |NTR/NUM| SHR   |                    |  NO   |SPC/ARW|  NO   |
     *                                                                       '-----------------------'                    '-----------------------'                          */
    [MAI] = LAYOUT_split_3x6_3_ex2(
        //  .----------------------------------------------------------------------------------------------------.     .-------------------------------------------------------------------------------------------------.
        CKC_BSD, KC_NO, KC_Q, KC_O, KC_U, KC_B, KC_NO, /*   */ KC_VOLU, KC_K, KC_G, KC_L, KC_W, KC_NO, KC_SCLN,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+---------------|     |-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_TAB, LT(SMB, KC_C), LSFT_T(KC_S), LALT_T(KC_E), LCTL_T(KC_A), KC_I, KC_NO, /*   */ KC_VOLD, KC_D, LCTL_T(KC_T), LALT_T(KC_R), LSFT_T(KC_N), LT(COD, KC_H), CKC_BSD,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+--------------´      `-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_ESC, KC_COMM, KC_Z, KC_X, KC_Y, KC_J, /*                                */ KC_F, KC_M, KC_V, KC_P, KC_DOT, KC_ESC,
        //  `------------------------------------------+-------------+-------------+--------------|                                  |-------------+-------------+-------------+-----------------------------------------´
        LTL, LTM, LTR, /*                                */ RTL, RTM, RTR)
    //                                          `----------------------------------------´                                   `----------------------------------------´
    // ===================================================================================================================================================================================================================
    /* QWERTY Layer
     *                                               .-------------------------------------------------------.    .-------------------------------------------------------.
     *                                               |BspDel |   Q   |   W   |   E   |   R   |   T   |  NO   |    | VOLU  |   Y   |   U   |   I   |   O   |   P   | SCLN  |
     *                                               |-------+-------+-------+-------+-------+-------+-------|    |-------+-------+-------+-------+-------+-------+-------|
     *                                               |  TAB  | A/SMB | S/SFT | D/ALT | F/CTL |   G   |  NO   |    | VOLD  |   H   | J/CTL | K/ALT | L/SFT | ;/COD |BspDel |
     *                                               |-------+-------+-------+-------+-------+-------+-------'    '-------|-------+-------+-------+-------+-------+-------|
     *                                               |  ESC  |   Z   |   X   |   C   |   V   |   B   |                    |   N   |   M   |   ,   |   .   |   '   |  ESC  |
     *                                               '-----------------------+-------+-------+-------|                    |-------+-------+-------+-----------------------'
     *                                                                       |  GUI  |NTR/NUM| SHR   |                    |  NO   |SPC/ARW|  NO   |
     *                                                                       '-----------------------'                    '-----------------------'                          */
    ,
    [QRT] = LAYOUT_split_3x6_3_ex2(
        //  .----------------------------------------------------------------------------------------------------.     .-------------------------------------------------------------------------------------------------.
        CKC_BSD, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_NO, /*   */ KC_VOLU, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_SCLN,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+---------------|     |-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_TAB, LT(SMB, KC_A), LSFT_T(KC_S), LALT_T(KC_D), LCTL_T(KC_F), KC_G, KC_NO, /*   */ KC_VOLD, KC_H, LCTL_T(KC_J), LALT_T(KC_K), LSFT_T(KC_L), LT(COD, KC_SCLN), CKC_BSD,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+--------------´      `-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_ESC, KC_Z, KC_X, KC_C, KC_V, KC_B, /*                                */ KC_N, KC_M, KC_COMM, KC_DOT, KC_QUOT, KC_ESC,
        //  `------------------------------------------+-------------+-------------+--------------|                                  |-------------+-------------+-------------+-----------------------------------------´
        LTL, LTM, LTR, /*                                */ RTL, RTM, RTR)
    //                                          `----------------------------------------´                                   `----------------------------------------´
    // ===================================================================================================================================================================================================================

    /* GAME Layer — no hold-modifiers on left hand
     *                                               .-------------------------------------------------------.    .-------------------------------------------------------.
     *                                               |BspDel |   Q   |   W   |   E   |   R   |   T   |  NO   |    | VOLU  |   Y   |   U   |   I   |   O   |   P   | SCLN  |
     *                                               |-------+-------+-------+-------+-------+-------+-------|    |-------+-------+-------+-------+-------+-------+-------|
     *                                               |  TAB  |   A   |   S   |   D   |   F   |   G   |  NO   |    | VOLD  |   H   | J/CTL | K/ALT | L/SFT | ;/COD |BspDel |
     *                                               |-------+-------+-------+-------+-------+-------+-------'    '-------|-------+-------+-------+-------+-------+-------|
     *                                               |  ESC  |   Z   |   X   |   C   |   V   |   B   |                    |   N   |   M   |   ,   |   .   |   '   |  ESC  |
     *                                               '-----------------------+-------+-------+-------|                    |-------+-------+-------+-----------------------'
     *                                                                       |  NO   |  NO   |  NO   |                    |  NO   |SPC/ARW|  NO   |
     *                                                                       '-----------------------'                    '-----------------------'                          */
    ,
    [GAM] = LAYOUT_split_3x6_3_ex2(
        //  .----------------------------------------------------------------------------------------------------.     .-------------------------------------------------------------------------------------------------.
        CKC_BSD, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_NO, /*   */ KC_VOLU, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_SCLN,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+---------------|     |-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_TAB, KC_A, KC_S, KC_D, KC_F, KC_G, KC_NO, /*   */ KC_VOLD, KC_H, LCTL_T(KC_J), LALT_T(KC_K), LSFT_T(KC_L), LT(COD, KC_SCLN), CKC_BSD,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+--------------´      `-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_ESC, KC_Z, KC_X, KC_C, KC_V, KC_B, /*                                */ KC_N, KC_M, KC_COMM, KC_DOT, KC_QUOT, KC_ESC,
        //  `------------------------------------------+-------------+-------------+--------------|                                  |-------------+-------------+-------------+-----------------------------------------´
        KC_NO, KC_NO, KC_NO, /*                                */ KC_TRNS, RTM, KC_TRNS)
    //                                          `----------------------------------------´                                   `----------------------------------------´
    // ===================================================================================================================================================================================================================

    /* NUMB Layer — Inverted numpad (1-2-3 top row, 7-8-9 bottom)
     *                                               .-------------------------------------------------------.    .-------------------------------------------------------.
     *                                               | TRNS  |  NO   |   1   |   2   |   3   |   +   |   *   |    | VOLU  | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  |
     *                                               |-------+-------+-------+-------+-------+-------+-------|    |-------+-------+-------+-------+-------+-------+-------|
     *                                               | TRNS  |  NO   | 4/SFT | 5/ALT | 6/CTL |   0   |   /   |    | VOLD  | TRNS  | CTL   | ALT   | SFT   | TRNS  | TRNS  |
     *                                               |-------+-------+-------+-------+-------+-------+-------'    '-------|-------+-------+-------+-------+-------+-------|
     *                                               | TRNS  | LOCK  |   7   |   8   |   9   |   -   |                    | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  |
     *                                               '-----------------------+-------+-------+-------|                    |-------+-------+-------+-----------------------'
     *                                                                       | TRNS  | TRNS  | TRNS  |                    | TRNS  | TRNS  | TRNS  |
     *                                                                       '-----------------------'                    '-----------------------'                          */
    ,
    [NUM] = LAYOUT_split_3x6_3_ex2(
        //  .----------------------------------------------------------------------------------------------------.     .-------------------------------------------------------------------------------------------------.
        KC_TRNS, KC_NO, KC_1, KC_2, KC_3, S(KC_EQL), S(KC_8), /*   */ KC_VOLU, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+---------------|     |-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_TRNS, KC_NO, LSFT_T(KC_4), LALT_T(KC_5), LCTL_T(KC_6), KC_0, KC_SLSH, /*   */ KC_VOLD, KC_TRNS, LCTL_T(KC_NO), LALT_T(KC_NO), LSFT_T(KC_NO), KC_TRNS, KC_TRNS,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+--------------´      `-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_TRNS, NUMB_T, KC_7, KC_8, KC_9, KC_MINS, /*                                */ KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,
        //  `------------------------------------------+-------------+-------------+--------------|                                  |-------------+-------------+-------------+-----------------------------------------´
        KC_TRNS, KC_TRNS, KC_TRNS, /*                                */ KC_TRNS, KC_TRNS, KC_TRNS)
    //                                          `----------------------------------------´                                   `----------------------------------------´
    // ===================================================================================================================================================================================================================

    /* SYMB Layer — Symbols (right hand, activated via left pinky hold)
     *                                               .-------------------------------------------------------.    .-------------------------------------------------------.
     *                                               | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  |  NO   |    | VOLU  |   -   |   ´   |   |   |   $   |   €   | TRNS  |
     *                                               |-------+-------+-------+-------+-------+-------+-------|    |-------+-------+-------+-------+-------+-------+-------|
     *                                               | TRNS  | TRNS  |  SFT  |  ALT  |  CTL  | TRNS  |  NO   |    | VOLD  |   _   |   '   |   &   |   #   |   @   | TRNS  |
     *                                               |-------+-------+-------+-------+-------+-------+-------'    '-------|-------+-------+-------+-------+-------+-------|
     *                                               | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  |                    |   "   |   `   |   %   |   *   |   :   | TRNS  |
     *                                               '-----------------------+-------+-------+-------|                    |-------+-------+-------+-----------------------'
     *                                                                       | TRNS  | TRNS  | TRNS  |                    | TRNS  | TRNS  | TRNS  |
     *                                                                       '-----------------------'                    '-----------------------'                          */
    ,
    [SMB] = LAYOUT_split_3x6_3_ex2(
        //  .----------------------------------------------------------------------------------------------------.     .-------------------------------------------------------------------------------------------------.
        KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_NO, /*   */ KC_VOLU, KC_MINS, KC_LBRC, S(KC_BSLS), S(KC_4), C(A(KC_5)), KC_TRNS,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+---------------|     |-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_TRNS, KC_TRNS, LSFT_T(KC_NO), LALT_T(KC_NO), LCTL_T(KC_NO), KC_TRNS, KC_NO, /*   */ KC_VOLD, S(KC_MINS), KC_QUOT, S(KC_7), S(KC_3), S(KC_2), KC_TRNS,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+--------------´      `-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, /*                                */ S(KC_QUOT), KC_GRV, S(KC_5), S(KC_8), S(KC_SCLN), KC_TRNS,
        //  `------------------------------------------+-------------+-------------+--------------|                                  |-------------+-------------+-------------+-----------------------------------------´
        KC_TRNS, KC_TRNS, KC_TRNS, /*                                */ KC_TRNS, KC_TRNS, KC_TRNS)
    //                                          `----------------------------------------´                                   `----------------------------------------´
    // ===================================================================================================================================================================================================================

    /* AROW Layer — Arrows and navigation (right hand, activated via RTM hold)
     *                                               .-------------------------------------------------------.    .-------------------------------------------------------.
     *                                               | TRNS  | TRNS  |   |   |   \   |   `   |   ]   |  NO   |    | VOLU  | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  |
     *                                               |-------+-------+-------+-------+-------+-------+-------|    |-------+-------+-------+-------+-------+-------+-------|
     *                                               | TRNS  | TRNS  |  SFT  |  ALT  |  CTL  | TRNS  |  NO   |    | VOLD  | TRNS  | LEFT  |  UP   | DOWN  | RIGHT | TRNS  |
     *                                               |-------+-------+-------+-------+-------+-------+-------'    '-------|-------+-------+-------+-------+-------+-------|
     *                                               | TRNS  | TRNS  | TRNS  |   !   |   ?   |   *   |                    | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  |
     *                                               '-----------------------+-------+-------+-------|                    |-------+-------+-------+-----------------------'
     *                                                                       | TRNS  | TRNS  | TRNS  |                    | TRNS  | TRNS  | TRNS  |
     *                                                                       '-----------------------'                    '-----------------------'                          */
    ,
    [ARW] = LAYOUT_split_3x6_3_ex2(
        //  .----------------------------------------------------------------------------------------------------.     .-------------------------------------------------------------------------------------------------.
        KC_TRNS, KC_TRNS, S(KC_BSLS), LSFT_T(KC_BSLS), KC_GRV, KC_RBRC, KC_NO, /*   */ KC_VOLU, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+---------------|     |-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_TRNS, KC_TRNS, LSFT_T(KC_NO), LALT_T(KC_NO), LCTL_T(KC_NO), KC_TRNS, KC_NO, /*   */ KC_VOLD, KC_TRNS, LCTL_T(KC_LEFT), LALT_T(KC_UP), LSFT_T(KC_DOWN), KC_RGHT, KC_TRNS,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+--------------´      `-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_TRNS, KC_TRNS, KC_TRNS, S(KC_1), S(KC_SLSH), S(KC_8), /*                                */ KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,
        //  `------------------------------------------+-------------+-------------+--------------|                                  |-------------+-------------+-------------+-----------------------------------------´
        KC_TRNS, KC_TRNS, KC_TRNS, /*                                */ KC_TRNS, KC_TRNS, KC_TRNS)
    //                                          `----------------------------------------´                                   `----------------------------------------´
    // ===================================================================================================================================================================================================================

    /* CODE Layer — Brackets and syntax (right hand, activated via right pinky hold)
     *                                               .-------------------------------------------------------.    .-------------------------------------------------------.
     *                                               | TRNS  | TRNS  |   ]   |   [   |   <   |   >   |  NO   |    | VOLU  | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  |
     *                                               |-------+-------+-------+-------+-------+-------+-------|    |-------+-------+-------+-------+-------+-------+-------|
     *                                               | TRNS  |   =   |   }   |   {   |   (   |   )   |  NO   |    | VOLD  | TRNS  |  CTL  |  ALT  |  SFT  | TRNS  | TRNS  |
     *                                               |-------+-------+-------+-------+-------+-------+-------'    '-------|-------+-------+-------+-------+-------+-------|
     *                                               | TRNS  |   ;   | TRNS  |   \   |   /   | TRNS  |                    | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  | TRNS  |
     *                                               '-----------------------+-------+-------+-------|                    |-------+-------+-------+-----------------------'
     *                                                                       | TRNS  | TRNS  | TRNS  |                    | TRNS  | TRNS  | TRNS  |
     *                                                                       '-----------------------'                    '-----------------------'                          */
    ,
    [COD] = LAYOUT_split_3x6_3_ex2(
        //  .----------------------------------------------------------------------------------------------------.     .-------------------------------------------------------------------------------------------------.
        KC_TRNS, KC_TRNS, KC_RBRC, KC_LBRC, S(KC_COMM), S(KC_DOT), KC_NO, /*   */ KC_VOLU, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+---------------|     |-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_TRNS, KC_EQL, S(KC_RBRC), S(KC_LBRC), S(KC_9), S(KC_0), KC_NO, /*   */ KC_VOLD, KC_TRNS, LCTL_T(KC_NO), LALT_T(KC_NO), LSFT_T(KC_NO), KC_TRNS, KC_TRNS,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+--------------´      `-------------+-------------+-------------+-------------+-------------+-------------+-------------|
        KC_TRNS, KC_SCLN, KC_TRNS, KC_BSLS, KC_SLSH, KC_TRNS, /*                                */ KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,
        //  `------------------------------------------+-------------+-------------+--------------|                                  |-------------+-------------+-------------+-----------------------------------------´
        KC_TRNS, KC_TRNS, KC_TRNS, /*                                */ KC_TRNS, KC_TRNS, KC_TRNS)
    //                                          `----------------------------------------´                                   `----------------------------------------´
    // ===================================================================================================================================================================================================================

    /* SHRT Layer — One-handed shortcuts (left hand, activated via LTR hold)
     *                                               .-------------------------------------------------------.    .-------------------------------------------------------.
     *                                               | TRNS  |  NO   | Ctrl+S| Ctrl+C| Ctrl+O|  NO   |  NO   |    | VOLU  |  NO   |  NO   |  NO   |  NO   |  NO   | TRNS  |
     *                                               |-------+-------+-------+-------+-------+-------+-------|    |-------+-------+-------+-------+-------+-------+-------|
     *                                               | TRNS  |  NO   | Ctrl+A| Ctrl+X| Ctrl+E|  NO   |  NO   |    | VOLD  |  NO   |  NO   |  NO   |  NO   |  NO   | TRNS  |
     *                                               |-------+-------+-------+-------+-------+-------+-------'    '-------|-------+-------+-------+-------+-------+-------|
     *                                               | TRNS  |  NO   | Ctrl+F| Ctrl+V| Ctrl+N|  NO   |                    |  NO   |  NO   |  NO   |  NO   |  NO   | TRNS  |
     *                                               '-----------------------+-------+-------+-------|                    |-------+-------+-------+-----------------------'
     *                                                                       | TRNS  | TRNS  | TRNS  |                    | TRNS  | TRNS  | TRNS  |
     *                                                                       '-----------------------'                    '-----------------------'                          */
    ,
    [SHR] = LAYOUT_split_3x6_3_ex2(
        //  .----------------------------------------------------------------------------------------------------.     .-------------------------------------------------------------------------------------------------.
        KC_TRNS, KC_NO, C(KC_S), C(KC_C), C(KC_O), KC_NO, KC_NO, /*   */ KC_VOLU, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_TRNS,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+---------------|     |-------------+-------------+-------------+-------------+-------------+-------------|
        KC_TRNS, KC_NO, C(KC_A), C(KC_X), C(KC_E), KC_NO, KC_NO, /*   */ KC_VOLD, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_TRNS,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+--------------´      `-------------|-------------|-------------|-------------|-------------|-------------|
        KC_TRNS, KC_NO, C(KC_F), C(KC_V), C(KC_N), KC_NO, /*                                */ KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_TRNS,
        //  `------------------------------------------+-------------+-------------+--------------|                                  |-------------+-------------+-------------+-----------------------------------------´
        KC_TRNS, KC_TRNS, KC_TRNS, /*                                */ KC_TRNS, KC_TRNS, KC_TRNS)
    //                                          `----------------------------------------´                                   `----------------------------------------´
    // ===================================================================================================================================================================================================================

    /* SWITCHER Layer — 3-thumb hold activates; tap a key to switch base layer
     *   Q → QWERTY   G → GAME   M → MAIN   B → BOOT   R → REBOOT
     *   LEDs: green (layer toggles), orange (boot), red (reboot)
     *                                               .-------------------------------------------------------.    .-------------------------------------------------------.
     *                                               |  NO   |  NO   |QWERTY |  NO   |  NO   | BOOT  |  NO   |    |  NO   |  NO   | GAME  |  NO   |  NO   |  NO   |  NO   |
     *                                               |-------+-------+-------+-------+-------+-------+-------|    |-------+-------+-------+-------+-------+-------+-------|
     *                                               |  NO   |  NO   |  NO   |  NO   |  NO   |  NO   |  NO   |    |  NO   |  NO   |  NO   | BOOT  |  NO   |  NO   |  NO   |
     *                                               |-------+-------+-------+-------+-------+-------+-------'    '-------|-------+-------+-------+-------+-------+-------|
     *                                               |  NO   |  NO   |  NO   |  NO   |  NO   |  NO   |                    |  NO   | MAIN  |  NO   |  NO   |  NO   |  NO   |
     *                                               '-----------------------+-------+-------+-------|                    |-------+-------+-------+-----------------------'
     *                                                                       | TRNS  | TRNS  | TRNS  |                    | TRNS  | TRNS  | TRNS  |
     *                                                                       '-----------------------'                    '-----------------------'                          */
    ,
    [SWX] = LAYOUT_split_3x6_3_ex2(
        //  .----------------------------------------------------------------------------------------------------.     .-------------------------------------------------------------------------------------------------.
        KC_NO, KC_NO, SW_QWRT, KC_NO, KC_NO, QK_BOOT, KC_NO, /*   */ KC_NO, KC_NO, SW_GAME, KC_NO, KC_NO, KC_NO, KC_NO,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+---------------|     |-------------+-------------+-------------+-------------+-------------+-------------|
        KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, /*   */ KC_NO, KC_NO, KC_NO, QK_BOOT, KC_NO, KC_NO, KC_NO,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+--------------´      `-------------|-------------|-------------|-------------|-------------|-------------|
        KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, /*                                */ KC_NO, SW_MAIN, KC_NO, KC_NO, KC_NO, KC_NO,
        //  `------------------------------------------+-------------+-------------+--------------|                                  |-------------+-------------+-------------+-----------------------------------------´
        KC_TRNS, KC_TRNS, KC_TRNS, /*                                */ KC_TRNS, KC_TRNS, KC_TRNS)
    //                                          `----------------------------------------´                                   `----------------------------------------´
    // ===================================================================================================================================================================================================================

    /* CONFIG Layer — Per-layer HSV adjustment (modifies current_base_layer config)
     *   Access: hold both ESCs for 500 ms   |   Exit: tap CFG_EXIT (ESC key positions)
     *   Ring (col 2):   LED_TOG (row 0) / VAL_UP (row 1) / VAL_DN (row 2)
     *   Middle (col 3): SAT_UP (row 1) / SAT_DN (row 2)
     *   Index (col 4):  HUE_UP (row 1) / HUE_DN (row 2)
     *   Inner (col 5):  CFG_RST (row 1) — reset layer configs to defaults
     *                   CFG_PRT (row 2) — print current config values
     *                                               .-------------------------------------------------------.    .-------------------------------------------------------.
     *                                               |  NO   |  NO   |LED_TOG|  NO   |  NO   |  NO   |  NO   |    |  NO   |  NO   |  NO   |  NO   |LED_TOG|  NO   |  NO   |
     *                                               |-------+-------+-------+-------+-------+-------+-------|    |-------+-------+-------+-------+-------+-------+-------|
     *                                               |  NO   |  NO   |VAL_UP |SAT_UP |HUE_UP |CFG_RST|  NO   |    |  NO   |CFG_RST|HUE_UP |SAT_UP |VAL_UP |  NO   |  NO   |
     *                                               |-------+-------+-------+-------+-------+-------+-------'    '-------|-------+-------+-------+-------+-------+-------|
     *                                               |CFG_EXT|  NO   |VAL_DN |SAT_DN |HUE_DN |CFG_PRT|                    |CFG_PRT|HUE_DN |SAT_DN |VAL_DN |  NO   |CFG_EXT|
     *                                               '-----------------------+-------+-------+-------|                    |-------+-------+-------+-----------------------'
     *                                                                       | TRNS  | TRNS  | TRNS  |                    | TRNS  | TRNS  | TRNS  |
     *                                                                       '-----------------------'                    '-----------------------'                          */
    ,
    [CNF] = LAYOUT_split_3x6_3_ex2(
        //  .----------------------------------------------------------------------------------------------------.     .-------------------------------------------------------------------------------------------------.
        KC_NO, KC_NO, LED_TOG, KC_NO, KC_NO, KC_NO, KC_NO, /*   */ KC_NO, KC_NO, KC_NO, KC_NO, LED_TOG, KC_NO, KC_NO,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+---------------|     |-------------+-------------+-------------+-------------+-------------+-------------|
        KC_NO, KC_NO, VAL_UP, SAT_UP, HUE_UP, CFG_RST, KC_NO, /*   */ KC_NO, CFG_RST, HUE_UP, SAT_UP, VAL_UP, KC_NO, KC_NO,
        //  |-------------+--------------+-------------+-------------+-------------+-------------+--------------´      `-------------|-------------|-------------|-------------|-------------|-------------|
        CFG_EXIT, KC_NO, VAL_DN, SAT_DN, HUE_DN, CFG_PRT, /*                                */ CFG_PRT, HUE_DN, SAT_DN, VAL_DN, KC_NO, CFG_EXIT,
        //  `------------------------------------------+-------------+-------------+--------------|                                  |-------------+-------------+-------------+-----------------------------------------´
        KC_TRNS, KC_TRNS, KC_TRNS, /*                                */ KC_TRNS, KC_TRNS, KC_TRNS)
    //                                          `----------------------------------------´                                   `----------------------------------------´
    // ===================================================================================================================================================================================================================
};

// =============================================================================
// STATE — Global variables grouped by feature
// =============================================================================

// --- NUMB layer toggle ---
static bool    numb_locked    = false;
static uint8_t previous_layer = MAI;

// --- Base layer tracking (updated by SWITCHER) ---
static uint8_t current_base_layer = MAI;

// --- Thumb cluster (SWITCHER detection + tap timers) ---
static bool     ltl_pressed       = false;
static bool     ltl_gui_activated = false; // GUI modifier was activated by another keypress
static uint16_t ltl_tap_timer     = 0;
static bool     ltm_pressed       = false;
static bool     ltr_pressed       = false;
static uint16_t left_thumb_timer  = 0;
static uint16_t ltm_tap_timer     = 0;
static uint16_t ltr_tap_timer     = 0;

static bool     rtl_pressed       = false;
static bool     rtm_pressed       = false;
static bool     rtr_pressed       = false;
static uint16_t right_thumb_timer = 0;
static uint16_t rtm_tap_timer     = 0;
static uint16_t rtl_tap_timer     = 0;

static bool switcher_activated = false;

// --- Double-tap-hold for key repeat (thumb keys with hold behavior) ---
// When you double-tap and hold within THUMB_REPEAT_TERM, the tap key repeats
// instead of activating the hold layer. This mimics standard keyboard behavior.
// To add this feature to other keys:
//   1. Add static uint16_t xxx_last_tap = 0;  (tracks last successful tap time)
//   2. Add static bool xxx_repeating = false; (tracks if currently repeating)
//   3. In press handler: check timer_elapsed(xxx_last_tap) < THUMB_REPEAT_TERM
//      - If true: set xxx_repeating=true, register_code(TAP_KEY), skip layer
//      - If false: normal hold behavior
//   4. In release handler: if xxx_repeating, unregister_code(TAP_KEY)
//      - Otherwise: if was quick tap, record xxx_last_tap = timer_read()
static uint16_t ltm_last_tap  = 0; // LTM: Enter tap / NUM hold
static bool     ltm_repeating = false;
static uint16_t rtm_last_tap  = 0; // RTM: Space tap / ARW hold
static bool     rtm_repeating = false;

// --- Dual-ESC (CONFIG detection) ---
static bool     left_esc_pressed  = false;
static bool     right_esc_pressed = false;
static uint16_t config_hold_timer = 0;
static bool     config_activated  = false;

// --- Per-layer LED config (persisted to EEPROM) ---
typedef struct {
    uint8_t hue;
    uint8_t sat;
    uint8_t val;
    bool    leds_enabled;
} layer_config_t;

// Default configs used on first boot / EEPROM reset
static const layer_config_t DEFAULT_LAYER_CONFIGS[3] = {
    {DEFAULT_HUE_MAI, DEFAULT_SAT_MAI, DEFAULT_VAL_MAI, true}, // MAI - Blue
    {DEFAULT_HUE_QRT, DEFAULT_SAT_QRT, DEFAULT_VAL_QRT, true}, // QRT - Green
    {DEFAULT_HUE_GAM, DEFAULT_SAT_GAM, DEFAULT_VAL_GAM, true}, // GAM - Red
};

// Runtime layer configs (loaded from EEPROM, modified by CNF layer)
static layer_config_t layer_configs[3] = {
    {DEFAULT_HUE_MAI, DEFAULT_SAT_MAI, DEFAULT_VAL_MAI, true},
    {DEFAULT_HUE_QRT, DEFAULT_SAT_QRT, DEFAULT_VAL_QRT, true},
    {DEFAULT_HUE_GAM, DEFAULT_SAT_GAM, DEFAULT_VAL_GAM, true},
};

// =============================================================================
// SPLIT SYNC — Layer config synchronization between halves
// =============================================================================

// Sync payload: layer configs + state variables needed by slave for LED display
typedef struct {
    layer_config_t configs[3];
    uint8_t        base_layer;
    bool           numb_locked;
} sync_payload_t;

// Sync timing: periodic resync every 10 second to recover from missed syncs
#define SYNC_INTERVAL_MS 10000
static uint32_t last_sync_time = 0;

// Handler called on slave when master sends config update
void config_sync_slave_handler(uint8_t in_buflen, const void *in_data, uint8_t out_buflen, void *out_data) {
    const sync_payload_t *payload = (const sync_payload_t *)in_data;
    for (uint8_t i = 0; i < 3; i++) {
        layer_configs[i] = payload->configs[i];
    }
    current_base_layer = payload->base_layer;
    numb_locked        = payload->numb_locked;
}

// Called on master to sync all state to slave
void sync_config_to_slave(void) {
    if (is_keyboard_master()) {
        sync_payload_t payload;
        for (uint8_t i = 0; i < 3; i++) {
            payload.configs[i] = layer_configs[i];
        }
        payload.base_layer  = current_base_layer;
        payload.numb_locked = numb_locked;
        transaction_rpc_send(USER_SYNC_CONFIG, sizeof(payload), &payload);
        last_sync_time = timer_read32();
    }
}

// =============================================================================
// LED HELPERS
// =============================================================================

// Returns the RGB colour for the given layer using per-layer config.
// If layer >= 3 (a temp layer) falls back to current_base_layer.
// Returns black (0,0,0) if LEDs are disabled for that layer.
RGB get_base_layer_color(uint8_t layer) {
    uint8_t         base_idx = (layer < 3) ? layer : current_base_layer;
    layer_config_t *cfg      = &layer_configs[base_idx];

    // If LEDs disabled, return black
    if (!cfg->leds_enabled) {
        RGB black = {0, 0, 0};
        return black;
    }

    HSV hsv = {cfg->hue, cfg->sat, cfg->val};
    return hsv_to_rgb(hsv);
}

// Immediately update all LEDs for CNF layer (call after any config change).
// Sets all LEDs to current layer color, then overlays red on exit keys.
void update_cnf_leds(void) {
    RGB color = get_base_layer_color(current_base_layer);
    rgb_matrix_set_color_all(color.r, color.g, color.b);

    // CFG_EXIT keys (ESC positions) — always red for visibility
    rgb_matrix_set_color(20, LED_BRIGHTNESS, 0, 0); // Left ESC
    rgb_matrix_set_color(43, LED_BRIGHTNESS, 0, 0); // Right ESC
}

// =============================================================================
// EEPROM PERSISTENCE — Layer configs (13 bytes total)
// =============================================================================
// Layout: [MAI: h,s,v,en][QRT: h,s,v,en][GAM: h,s,v,en][checksum]

void save_layer_configs(void) {
    uint8_t data[13];
    for (uint8_t i = 0; i < 3; i++) {
        data[i * 4 + 0] = layer_configs[i].hue;
        data[i * 4 + 1] = layer_configs[i].sat;
        data[i * 4 + 2] = layer_configs[i].val;
        data[i * 4 + 3] = layer_configs[i].leds_enabled ? 1 : 0;
    }
    // Simple checksum: XOR of first 12 bytes
    data[12] = 0;
    for (uint8_t i = 0; i < 12; i++) {
        data[12] ^= data[i];
    }
    eeconfig_update_user_datablock(data);
}

static void load_layer_configs(void) {
    uint8_t data[13];
    eeconfig_read_user_datablock(data);

    // Verify checksum
    uint8_t checksum = 0;
    for (uint8_t i = 0; i < 12; i++) {
        checksum ^= data[i];
    }

    // If checksum matches and first byte isn't 0xFF (uninitialized), load configs
    if (checksum == data[12] && data[0] != 0xFF) {
        for (uint8_t i = 0; i < 3; i++) {
            layer_configs[i].hue          = data[i * 4 + 0];
            layer_configs[i].sat          = data[i * 4 + 1];
            layer_configs[i].val          = data[i * 4 + 2];
            layer_configs[i].leds_enabled = data[i * 4 + 3] != 0;
        }
    }
    // Otherwise keep defaults (set at declaration)
}

void eeconfig_init_user(void) {
    // Reset to defaults and save
    for (uint8_t i = 0; i < 3; i++) {
        layer_configs[i] = DEFAULT_LAYER_CONFIGS[i];
    }
    save_layer_configs();
}

// =============================================================================
// KEYBOARD INIT
// =============================================================================

void keyboard_post_init_user(void) {
    // Register split sync handler for layer configs (on slave side)
    transaction_register_rpc(USER_SYNC_CONFIG, config_sync_slave_handler);

    load_layer_configs();

    // RGB: no animation mode — all coloring done in rgb_matrix_indicators_user via HSV→RGB
    rgb_matrix_enable_noeeprom();
    rgb_matrix_mode_noeeprom(RGB_MATRIX_NONE);

    // Always start on MAI regardless of what EEPROM / bootmagic left behind
    default_layer_set(1 << MAI);
    layer_move(MAI);
    current_base_layer = MAI;
    switcher_activated = false;
    config_activated   = false;
    numb_locked        = false;

    // Sync initial configs to slave
    sync_config_to_slave();
}

// =============================================================================
// CUSTOM KEYCODES — process_record_user
// =============================================================================

uint8_t mod_state;

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    mod_state = get_mods();

    // --- LTL homerow-style GUI activation ---
    // If LTL is held and another (non-thumb) key is pressed, activate GUI as modifier
    if (ltl_pressed && !ltl_gui_activated && !switcher_activated && record->event.pressed) {
        if (keycode != LTL && keycode != LTM && keycode != LTR && keycode != RTL && keycode != RTM && keycode != RTR) {
            register_code(KC_LGUI);
            ltl_gui_activated = true;
        }
    }

    switch (keycode) {
        // --- Macro keys ---
        case CKC_QU:
            if (mod_state & MOD_MASK_CS) {
                del_mods(MOD_MASK_CS);
                if (record->event.pressed)
                    register_code(KC_Q);
                else
                    unregister_code(KC_Q);
                set_mods(mod_state);
            } else {
                if (record->event.pressed) {
                    tap_code(KC_Q);
                    tap_code(KC_U);
                }
            }
            return false;

        case CKC_BSD: {
            static bool delkey_registered;
            if (record->event.pressed) {
                if (mod_state & MOD_MASK_SHIFT) {
                    del_mods(MOD_MASK_SHIFT);
                    register_code(KC_DEL);
                    delkey_registered = true;
                    set_mods(mod_state);
                } else {
                    register_code(KC_BSPC);
                }
            } else {
                if (delkey_registered) {
                    unregister_code(KC_DEL);
                    delkey_registered = false;
                } else {
                    unregister_code(KC_BSPC);
                }
            }
            return false;
        }

        // --- NUMB toggle ---
        case NUMB_T:
            if (record->event.pressed) {
                if (!numb_locked) {
                    numb_locked    = true;
                    previous_layer = get_highest_layer(layer_state & ~(1 << NUM));
                    layer_on(NUM);
                } else {
                    numb_locked = false;
                    layer_off(NUM);
                    layer_move(previous_layer);
                }
                sync_config_to_slave(); // Sync numb_locked state for LED display
            }
            return false;

        // --- SWITCHER base-layer keys ---
        case SW_MAIN:
            if (record->event.pressed) {
                current_base_layer = MAI;
                numb_locked        = false;
                layer_off(SWX);
                layer_move(MAI);
                sync_config_to_slave();
            }
            return false;

        case SW_QWRT:
            if (record->event.pressed) {
                current_base_layer = QRT;
                numb_locked        = false;
                layer_off(SWX);
                layer_move(QRT);
                sync_config_to_slave();
            }
            return false;

        case SW_GAME:
            if (record->event.pressed) {
                current_base_layer = GAM;
                numb_locked        = false;
                layer_off(SWX);
                layer_move(GAM);
                sync_config_to_slave();
            }
            return false;

        // --- Left thumb cluster ---
        case LTL: // GUI hold (modifier, homerow-style) / GUI tap
            if (record->event.pressed) {
                ltl_pressed       = true;
                ltl_gui_activated = false;
                ltl_tap_timer     = timer_read();
                if (ltl_pressed && ltm_pressed && ltr_pressed && left_thumb_timer == 0) left_thumb_timer = timer_read();
                // Don't register GUI yet — wait for another keypress (homerow-style)
            } else {
                ltl_pressed      = false;
                left_thumb_timer = 0;
                if (!switcher_activated) {
                    if (ltl_gui_activated) {
                        // Was used as modifier — just release it
                        unregister_code(KC_LGUI);
                        ltl_gui_activated = false;
                    } else if (timer_elapsed(ltl_tap_timer) < THUMB_TAP_TERM) {
                        // Quick release, no other key pressed — tap GUI
                        tap_code(KC_LGUI);
                    }
                    // Slow release with no other key → do nothing
                }
                ltl_gui_activated = false;
            }
            return false;

        case LTM: // Enter tap / NUM hold (supports double-tap-hold for repeat)
            if (record->event.pressed) {
                ltm_pressed   = true;
                ltm_tap_timer = timer_read();
                if (ltl_pressed && ltm_pressed && ltr_pressed && left_thumb_timer == 0) left_thumb_timer = timer_read();

                // Double-tap-hold detection: if tapped recently, repeat Enter instead of hold
                if (!switcher_activated && !(ltl_pressed && ltr_pressed)) {
                    if (timer_elapsed(ltm_last_tap) < THUMB_REPEAT_TERM) {
                        // Second tap within window - enter repeat mode
                        ltm_repeating = true;
                        register_code(KC_ENT); // Will auto-repeat while held
                    } else {
                        // Normal hold - activate NUM layer
                        layer_on(NUM);
                    }
                }
            } else {
                ltm_pressed      = false;
                left_thumb_timer = 0;
                if (!switcher_activated && !numb_locked) {
                    if (ltm_repeating) {
                        // Was repeating - just unregister
                        unregister_code(KC_ENT);
                        ltm_repeating = false;
                    } else {
                        // Normal release - check for tap
                        layer_off(NUM);
                        if (timer_elapsed(ltm_tap_timer) < THUMB_TAP_TERM) {
                            tap_code(KC_ENT);
                            ltm_last_tap = timer_read(); // Record for double-tap detection
                        }
                    }
                }
            }
            return false;

        case LTR: // SHR hold — or Shift+tap → toggle Caps Lock
            if (record->event.pressed) {
                ltr_pressed   = true;
                ltr_tap_timer = timer_read();
                if (ltl_pressed && ltm_pressed && ltr_pressed && left_thumb_timer == 0) left_thumb_timer = timer_read();
                // Only activate SHR if Shift is NOT held (Shift+tap reserved for caps toggle)
                if (!switcher_activated && !(ltl_pressed && ltm_pressed) && !(get_mods() & MOD_MASK_SHIFT)) layer_on(SHR);
            } else {
                ltr_pressed      = false;
                left_thumb_timer = 0;
                if (!switcher_activated) {
                    layer_off(SHR);
                    // Shift held + quick tap → toggle Caps Lock (check current mods, not stale mod_state)
                    if ((get_mods() & MOD_MASK_SHIFT) && timer_elapsed(ltr_tap_timer) < THUMB_TAP_TERM) {
                        tap_code(KC_CAPS);
                    }
                }
            }
            return false;

        // --- Right thumb cluster ---
        case RTL: // Shift+tap → toggle Caps Lock (mirrors LTR)
            if (record->event.pressed) {
                rtl_pressed   = true;
                rtl_tap_timer = timer_read();
                if (rtl_pressed && rtm_pressed && rtr_pressed && right_thumb_timer == 0) right_thumb_timer = timer_read();
            } else {
                rtl_pressed       = false;
                right_thumb_timer = 0;
                if (!switcher_activated) {
                    // Shift held + quick tap → toggle Caps Lock (check current mods, not stale mod_state)
                    if ((get_mods() & MOD_MASK_SHIFT) && timer_elapsed(rtl_tap_timer) < THUMB_TAP_TERM) {
                        tap_code(KC_CAPS);
                    }
                }
            }
            return false;

        case RTM: // Space tap / ARW hold (supports double-tap-hold for repeat)
            if (record->event.pressed) {
                rtm_pressed   = true;
                rtm_tap_timer = timer_read();
                if (rtl_pressed && rtm_pressed && rtr_pressed && right_thumb_timer == 0) right_thumb_timer = timer_read();

                // Double-tap-hold detection: if tapped recently, repeat Space instead of hold
                if (!switcher_activated && !(rtl_pressed && rtr_pressed)) {
                    if (timer_elapsed(rtm_last_tap) < THUMB_REPEAT_TERM) {
                        // Second tap within window - enter repeat mode
                        rtm_repeating = true;
                        register_code(KC_SPC); // Will auto-repeat while held
                    } else {
                        // Normal hold - activate ARW layer
                        layer_on(ARW);
                    }
                }
            } else {
                rtm_pressed       = false;
                right_thumb_timer = 0;
                if (!switcher_activated) {
                    if (rtm_repeating) {
                        // Was repeating - just unregister
                        unregister_code(KC_SPC);
                        rtm_repeating = false;
                    } else {
                        // Normal release - check for tap
                        layer_off(ARW);
                        if (timer_elapsed(rtm_tap_timer) < THUMB_TAP_TERM) {
                            tap_code(KC_SPC);
                            rtm_last_tap = timer_read(); // Record for double-tap detection
                        }
                    }
                }
            }
            return false;

        case RTR: // placeholder
            if (record->event.pressed) {
                rtr_pressed = true;
                if (rtl_pressed && rtm_pressed && rtr_pressed && right_thumb_timer == 0) right_thumb_timer = timer_read();
            } else {
                rtr_pressed       = false;
                right_thumb_timer = 0;
            }
            return false;

        // --- CONFIG layer HSV controls (modify current_base_layer) ---
        case LED_TOG:
            if (record->event.pressed) {
                layer_configs[current_base_layer].leds_enabled = !layer_configs[current_base_layer].leds_enabled;
                update_cnf_leds();
                sync_config_to_slave();
            }
            return false;

        case HUE_UP:
            if (record->event.pressed) {
                uint8_t h                             = layer_configs[current_base_layer].hue;
                layer_configs[current_base_layer].hue = (h <= HSV_MAX - HSV_STEP) ? h + HSV_STEP : HSV_MAX;
                update_cnf_leds();
                sync_config_to_slave();
            }
            return false;

        case HUE_DN:
            if (record->event.pressed) {
                uint8_t h                             = layer_configs[current_base_layer].hue;
                layer_configs[current_base_layer].hue = (h >= HSV_MIN + HSV_STEP) ? h - HSV_STEP : HSV_MIN;
                update_cnf_leds();
                sync_config_to_slave();
            }
            return false;

        case SAT_UP:
            if (record->event.pressed) {
                uint8_t s                             = layer_configs[current_base_layer].sat;
                layer_configs[current_base_layer].sat = (s <= HSV_MAX - HSV_STEP) ? s + HSV_STEP : HSV_MAX;
                update_cnf_leds();
                sync_config_to_slave();
            }
            return false;

        case SAT_DN:
            if (record->event.pressed) {
                uint8_t s                             = layer_configs[current_base_layer].sat;
                layer_configs[current_base_layer].sat = (s >= HSV_MIN + HSV_STEP) ? s - HSV_STEP : HSV_MIN;
                update_cnf_leds();
                sync_config_to_slave();
            }
            return false;

        case VAL_UP:
            if (record->event.pressed) {
                uint8_t v                             = layer_configs[current_base_layer].val;
                layer_configs[current_base_layer].val = (v <= HSV_MAX - HSV_STEP) ? v + HSV_STEP : HSV_MAX;
                update_cnf_leds();
                sync_config_to_slave();
            }
            return false;

        case VAL_DN:
            if (record->event.pressed) {
                uint8_t v                             = layer_configs[current_base_layer].val;
                layer_configs[current_base_layer].val = (v >= HSV_MIN + HSV_STEP) ? v - HSV_STEP : HSV_MIN;
                update_cnf_leds();
                sync_config_to_slave();
            }
            return false;

        case CFG_EXIT:
            if (record->event.pressed) {
                save_layer_configs(); // Save to EEPROM only on exit
                sync_config_to_slave();
                layer_off(CNF);
                config_activated = false;
            }
            return false;

        case CFG_RST:
            if (record->event.pressed) {
                // Reset layer configs to defaults and save to EEPROM
                eeconfig_init_user();
                sync_config_to_slave();
                update_cnf_leds(); // Show the reset colors immediately
            }
            return false;

        case CFG_PRT:
            if (record->event.pressed) {
                // Type out current config values for all layers
                char buf[128];
                snprintf(buf, sizeof(buf), "MAI:%d,%d,%d QRT:%d,%d,%d GAM:%d,%d,%d", layer_configs[MAI].hue, layer_configs[MAI].sat, layer_configs[MAI].val, layer_configs[QRT].hue, layer_configs[QRT].sat, layer_configs[QRT].val, layer_configs[GAM].hue, layer_configs[GAM].sat, layer_configs[GAM].val);
                send_string(buf);
            }
            return false;

        // --- Dual-ESC CONFIG access ---
        case KC_ESC: {
            uint8_t row          = record->event.key.row;
            uint8_t col          = record->event.key.col;
            bool    is_left_esc  = (row == 2 && col == 0);
            bool    is_right_esc = (row == 6 && col == 0);

            if (is_left_esc) {
                if (record->event.pressed) {
                    left_esc_pressed = true;
                    if (left_esc_pressed && right_esc_pressed && config_hold_timer == 0) config_hold_timer = timer_read();
                } else {
                    left_esc_pressed = false;
                    if (!config_activated) tap_code(KC_ESC);
                    config_hold_timer = 0;
                }
                return false;
            }
            if (is_right_esc) {
                if (record->event.pressed) {
                    right_esc_pressed = true;
                    if (left_esc_pressed && right_esc_pressed && config_hold_timer == 0) config_hold_timer = timer_read();
                } else {
                    right_esc_pressed = false;
                    if (!config_activated) tap_code(KC_ESC);
                    config_hold_timer = 0;
                }
                return false;
            }
            return true; // other ESC keys pass through
        }

        default:
            return true;
    }
}

// =============================================================================
// MATRIX SCAN — timed hold detection (SWITCHER + CONFIG)
// =============================================================================

// Helper: clear all temporary layers and register no held keys
static void clear_temp_layers(void) {
    layer_off(NUM);
    layer_off(SMB);
    layer_off(ARW);
    layer_off(COD);
    layer_off(SHR);
    unregister_code(KC_LGUI);
    ltl_gui_activated = false;
    unregister_code(KC_SPC);
}

void matrix_scan_user(void) {
    // --- SWITCHER: left thumb triple-hold ---
    if (ltl_pressed && ltm_pressed && ltr_pressed && left_thumb_timer > 0) {
        if (timer_elapsed(left_thumb_timer) >= SWITCHER_HOLD_TIME && !switcher_activated) {
            switcher_activated = true;
            clear_temp_layers();
            layer_on(SWX);
            left_thumb_timer = 0;
        }
    }

    // --- SWITCHER: right thumb triple-hold ---
    if (rtl_pressed && rtm_pressed && rtr_pressed && right_thumb_timer > 0) {
        if (timer_elapsed(right_thumb_timer) >= SWITCHER_HOLD_TIME && !switcher_activated) {
            switcher_activated = true;
            clear_temp_layers();
            layer_on(SWX);
            right_thumb_timer = 0;
        }
    }

    // Reset flag once SWITCHER layer is off
    if (switcher_activated && !layer_state_is(SWX)) {
        switcher_activated = false;
    }

    // --- CONFIG: dual-ESC hold ---
    if (left_esc_pressed && right_esc_pressed && config_hold_timer > 0) {
        if (timer_elapsed(config_hold_timer) >= CONFIG_HOLD_TIME && !config_activated) {
            config_activated = true;
            clear_temp_layers();
            layer_off(SWX);
            layer_on(CNF);
            config_hold_timer = 0;
        }
    }

    // Reset flag once CONFIG layer is off
    if (config_activated && !layer_state_is(CNF)) {
        config_activated = false;
    }
}

// =============================================================================
// RGB MATRIX INDICATORS
// =============================================================================

bool rgb_matrix_indicators_user(void) {
    uint8_t layer = get_highest_layer(layer_state | default_layer_state);

    // --- SWITCHER: colour-coded spotlights only ---
    if (layer == SWX) {
        rgb_matrix_set_color_all(0, 0, 0);

        // Green – layer toggles
        rgb_matrix_set_color(12, 0, LED_BRIGHTNESS, 0); // Q  – QWERTY
        rgb_matrix_set_color(27, 0, LED_BRIGHTNESS, 0); // G  – GAME
        rgb_matrix_set_color(29, 0, LED_BRIGHTNESS, 0); // M  – MAIN

        // Orange – bootloader
        rgb_matrix_set_color(3, LED_BRIGHTNESS, LED_BRIGHTNESS / 2, 0); // B  – BOOT

        // Red – reboot
        rgb_matrix_set_color(33, LED_BRIGHTNESS, 0, 0); // R  – REBOOT
        return false;
    }

    // --- CONFIG: base color for real-time feedback, only ESC keys red ---
    if (layer == CNF) {
        RGB color = get_base_layer_color(current_base_layer);
        rgb_matrix_set_color_all(color.r, color.g, color.b);

        // CFG_EXIT keys (ESC positions, row 2 col 0) – red
        rgb_matrix_set_color(20, LED_BRIGHTNESS, 0, 0); // Left ESC
        rgb_matrix_set_color(43, LED_BRIGHTNESS, 0, 0); // Right ESC
        return false;
    }

    // --- NUMB locked: numpad key colours ---
    if (numb_locked && layer == NUM) {
        rgb_matrix_set_color_all(0, 0, 0);

        // Digits – warm white
        rgb_matrix_set_color(12, WARM_LED_R, WARM_LED_G, WARM_LED_B); // 1
        rgb_matrix_set_color(11, WARM_LED_R, WARM_LED_G, WARM_LED_B); // 2
        rgb_matrix_set_color(4, WARM_LED_R, WARM_LED_G, WARM_LED_B);  // 3
        rgb_matrix_set_color(13, WARM_LED_R, WARM_LED_G, WARM_LED_B); // 4
        rgb_matrix_set_color(10, WARM_LED_R, WARM_LED_G, WARM_LED_B); // 5
        rgb_matrix_set_color(5, WARM_LED_R, WARM_LED_G, WARM_LED_B);  // 6
        rgb_matrix_set_color(14, WARM_LED_R, WARM_LED_G, WARM_LED_B); // 7
        rgb_matrix_set_color(9, WARM_LED_R, WARM_LED_G, WARM_LED_B);  // 8
        rgb_matrix_set_color(6, WARM_LED_R, WARM_LED_G, WARM_LED_B);  // 9
        rgb_matrix_set_color(2, WARM_LED_R, WARM_LED_G, WARM_LED_B);  // 0

        // + – : yellow
        rgb_matrix_set_color(3, LED_BRIGHTNESS, (LED_BRIGHTNESS * NUMPAD_YELLOW_G) / 255, 0);
        rgb_matrix_set_color(1, LED_BRIGHTNESS, (LED_BRIGHTNESS * NUMPAD_YELLOW_G) / 255, 0);

        // * / : orange
        rgb_matrix_set_color(21, LED_BRIGHTNESS, (LED_BRIGHTNESS * NUMPAD_ORANGE_G) / 255, 0);
        rgb_matrix_set_color(22, LED_BRIGHTNESS, (LED_BRIGHTNESS * NUMPAD_ORANGE_G) / 255, 0);

        // Lock key – green
        rgb_matrix_set_color(15, 0, LED_BRIGHTNESS, 0);

        // fall through → modifier indicators still rendered below
    } else {
        // --- All other layers: solid base-layer colour ---
        RGB color = get_base_layer_color(layer);
        rgb_matrix_set_color_all(color.r, color.g, color.b);
    }

    // --- Modifier column indicators (fixed brightness, always on top) ---
    uint8_t mods = get_mods() | get_oneshot_mods();

    if (mods & MOD_MASK_CTRL) { // index columns — warm white
        rgb_matrix_set_color(4, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(5, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(6, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(27, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(28, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(29, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
    }

    if (mods & MOD_MASK_SHIFT) { // ring columns — warm white
        rgb_matrix_set_color(12, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(13, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(14, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(35, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(36, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(37, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
    }

    if (mods & MOD_MASK_ALT) { // middle columns — warm white
        rgb_matrix_set_color(11, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(10, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(9, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(34, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(33, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
        rgb_matrix_set_color(32, WARM_MOD_R, WARM_MOD_G, WARM_MOD_B);
    }

    // --- Layer pinky-column indicators ---
    if (layer_state_is(SMB)) { // left pinky
        rgb_matrix_set_color(17, LED_BRIGHTNESS, LED_BRIGHTNESS, LED_BRIGHTNESS);
        rgb_matrix_set_color(16, LED_BRIGHTNESS, LED_BRIGHTNESS, LED_BRIGHTNESS);
        rgb_matrix_set_color(15, LED_BRIGHTNESS, LED_BRIGHTNESS, LED_BRIGHTNESS);
    }

    if (layer_state_is(COD)) { // right pinky
        rgb_matrix_set_color(40, LED_BRIGHTNESS, LED_BRIGHTNESS, LED_BRIGHTNESS);
        rgb_matrix_set_color(39, LED_BRIGHTNESS, LED_BRIGHTNESS, LED_BRIGHTNESS);
        rgb_matrix_set_color(38, LED_BRIGHTNESS, LED_BRIGHTNESS, LED_BRIGHTNESS);
    }

    // --- Caps Lock indicator: all 6 thumbs go red ---
    if (host_keyboard_led_state().caps_lock) {
        rgb_matrix_set_color(8, LED_BRIGHTNESS, 0, 0);  // LTL
        rgb_matrix_set_color(7, LED_BRIGHTNESS, 0, 0);  // LTM
        rgb_matrix_set_color(0, LED_BRIGHTNESS, 0, 0);  // LTR
        rgb_matrix_set_color(23, LED_BRIGHTNESS, 0, 0); // RTL
        rgb_matrix_set_color(30, LED_BRIGHTNESS, 0, 0); // RTM
        rgb_matrix_set_color(31, LED_BRIGHTNESS, 0, 0); // RTR
    }

    return false; // we fully own LED output
}

// =============================================================================
// HOUSEKEEPING — Periodic sync to recover from missed updates
// =============================================================================

void housekeeping_task_user(void) {
    // Periodic sync: re-sync every SYNC_INTERVAL_MS to handle edge cases:
    // - Slave rebooting/reconnecting
    // - Initial sync failure
    // - Any missed sync during rapid keypresses
    if (is_keyboard_master()) {
        if (timer_elapsed32(last_sync_time) > SYNC_INTERVAL_MS) {
            sync_config_to_slave();
        }
    }
}
